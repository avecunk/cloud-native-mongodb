# MongoDB Indexing

## Prepare a fresh mongodb

We create a fresh MongoDB and a container to connect from and interact with it

    $ docker run --name advanced-mongo -d mongo

    # We use the cmd container we created in *mongodb-basics* to interact:
    $ docker run -it --link advanced-mongo:mongodb --rm mongo-cmd bash
    
    # inside the container:
    $ mongoimport -h mongodb --db test --collection restaurants --drop --file /sampledata/primer-dataset.json
    $ mongo mongodb:27017/test

## Let's create a helper function to examine indexes

As there is no `show indexes` (like `show collections`), we can write a small helper:

    > function showIndexes(collection) { 
        collection.getIndexes().forEach(function(index) { 
            let keys = Object.keys(index.key);
            print(index.name + ": " + keys.join(', '))
        }) 
    }

## Create a simple index

Allow searching for `cuisine` faster:

    > db.restaurants.createIndex( { "cuisine": 1 } )

Use our helper function to show the fields used for the new index:

    > showIndexes(db.restaurants)

This outputs the default index on `_id` and our newly created one:

    _id_: _id
    cuisine_1: cuisine

## Create a compound index

    > db.restaurants.createIndex({"cuisine": 1, "address.zipcode": -1})
    > showIndexes(db.restaurants)

This shows the auto-generated name for the new index:

    _id_: _id
    cuisine_1: cuisine
    cuisine_1_address.zipcode_-1: cuisine, address.zipcode

## Specify an own name for the index

Autogenerated index names might be hard to work with, we can remove the index with `dropIndex()`
and re-create it with a more user friendly name:

    > db.restaurants.dropIndex("cuisine_1_address.zipcode_-1")
    > db.restaurants.createIndex({ "cuisine": 1, "address.zipcode": -1 }, { name: "reverse_zipcode" })
    > showIndexes(db.restaurants)

This will output:

    _id_: _id
    cuisine_1: cuisine
    reverse_zipcode: cuisine, address.zipcode

## Drop all user generated indexes

    > db.restaurants.dropIndexes()
    > showIndexes(db.restaurants)

The output will now show only the `_id_` index, which can't be dropped.
If you try to drop this index via `db.restaurants.dropIndex("_id_")`, you receive an error.

## Create a partial index

Partial indexes can be used to index only parts of a collection:

    > db.restaurants.createIndex(
        { cuisine: 1, name: 1 },
        { partialFilterExpression: { rating: { $gt: 5 } } }
    )

## Create a unique index

Let's try to create a unique index on restaurants to avoid duplicates:

    > db.restaurants.createIndex({ name: 1 }, { unique: true })
    # Error!

Oops, seems there are multiple restaurants with the same name...

## Create a TTL index

TTL indexes work on data fields and will remove documents from the indexed collection after the configured time.
This can be useful for log-type collections.

    > db.restaurantVisits.createIndex( { "visited": 1 }, { expireAfterSeconds: 60 } )
    
Create a few entries with 5 seconds between them:

    > ["Urs", "Beat", "Hans", "Roger"].forEach(function(name) {
        db.restaurantVisits.insert({ name: name, visited: new ISODate() })
        sleep(5000)
    })

If you immediately issue a find, all documents are returned:

    > db.restaurantVisits.find()

After waiting a few more seconds, they disappear one by one if you repeat the `.find()` query.

## Using fulltext search

Try to do a fulltext search:

    > db.restaurants.find({ $text: { $search: "Domino" } })
    # Error!

That won't work - we need to create a fulltext index first:

    > db.restaurants.createIndex( { name: "text" }, { name: "naive_fulltext" } )

Now we can search:

    > db.restaurants.find({ $text: {$search: "Sushi" } })

Nice, lots of results. But can we also find Filipino food via fulltext search?

    > db.restaurants.find({ $text: {$search: "Filipino" } })

No results? Lets add all the text fields of the document to the index, via the `$**` wildcard operator 
(for that, we need to drop the existing index first, as there can only be one fulltext index per collection):

    > db.restaurants.dropIndex("naive_fulltext")
    > db.restaurants.createIndex({ "$**": "text" })

Now, we should be able to find Filipino food, too:

    > db.restaurants.find({ $text: {$search: "Filipino" } })

Fulltext indexes support a lot more options, like weighting individual fields, or specifying a language.